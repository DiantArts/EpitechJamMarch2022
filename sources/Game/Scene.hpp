#pragma once

namespace xrn {

class Scene {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // *structors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Scene(
        ::xrn::Window& window
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Actions
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Updates the scene
    ///
    /// Calls actors updates
    //
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto update()
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    void spawnObstacles();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Draws the scene
    ///
    /// Calls actors draws
    ///
    ///////////////////////////////////////////////////////////////////////////
    void draw() const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Is over
    ///
    /// If window is closed or should close
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isOver() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Handles each events given by window
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto handleEvent(
        sf::Event& event
    ) -> bool;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getScore() const
        -> ::std::size_t;



private:

    ::xrn::ecs::component::Container m_components{};
    ::xrn::ecs::entity::Container m_entities{ m_components };
    mutable ::xrn::Clock m_clock{};
    ::xrn::ecs::system::Container m_systems{};
    mutable ::xrn::Clock m_clockUpdate{};
    ::xrn::ecs::system::Container m_updateSystems{};
    mutable ::xrn::Clock m_constClock{};
    ::xrn::ecs::system::ConstContainer m_constSystems{};

    mutable ::xrn::Clock m_obstacleClock{};
    ::xrn::Time m_obstacleRate{ 2000 };
    int m_enemySpeed{ 500 };

    ::xrn::Window& m_window;
    bool m_isOver{ false };

    ::xrn::Id m_playerId{ 0 };

    ::xrn::Clock m_scoreClock{};
    ::std::size_t m_score{ 0 };
    ::xrn::Id m_scoreId{ 0 };

    ::std::array<::std::size_t, 4> m_backgroundIds;

};



} // namespace xrn
