///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>
#include <xrn/Ecs.hpp>
#include <Game/Window.hpp>
#include <Game/Scene.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// *structors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::component::Movable::Movable() = default;



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Position
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::moveRight(
    float offset
)
{
    m_position.x += offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::moveLeft(
    float offset
)
{
    m_position.x -= offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::moveUp(
    float offset
)
{
    m_position.y -= offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::moveDown(
    float offset
)
{
    m_position.y += offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::move(
    const ::sf::Vector2<float>& offset
)
{
    m_position += offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::move(
    float offsetX,
    float offsetY
)
{
    m_position.x += offsetX;
    m_position.y += offsetY;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::moveX(
    float offset
)
{
    m_position.y += offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::moveY(
    float offset
)
{
    m_position.y += offset;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setPosition(
    const ::sf::Vector2<float> position
)
{
    m_position = position;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setPosition(
    float positionX,
    float positionY
)
{
    m_position.x = positionX;
    m_position.y = positionY;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setPositionX(
    float position
)
{
    m_position.x = position;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setPositionY(
    float position
)
{
    m_position.y = position;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::updatePosition(
    ::xrn::Time deltaTime
)
{
    m_position.x += (deltaTime / 1000) * m_direction.x * m_speed.x;
    m_position.y += (deltaTime / 1000) * m_direction.y * m_speed.y;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::component::Movable::getPosition() const
    -> const ::sf::Vector2<float>&
{
    return m_position;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Speed
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setSpeed(
    const ::sf::Vector2<float>& speed
)
{
    if (m_speed.x >= -this->maxSpeed && m_speed.x <= this->maxSpeed) {
        m_speed.x = speed.x;
    } else if (speed.x > m_speed.x) {
        m_speed.x = this->maxSpeed;
    } else if (speed.x < m_speed.x) {
        m_speed.x = -this->maxSpeed;
    }
    m_speed.y = speed.y;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::component::Movable::getSpeed() const
    -> const ::sf::Vector2<float>&
{
    return m_speed;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setDirection(
    const ::sf::Vector2<float>& direction
)
{
    m_direction = direction;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::component::Movable::getDirection()
    -> ::sf::Vector2<float>&
{
    return m_direction;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::component::Movable::getDirection() const
    -> const ::sf::Vector2<float>&
{
    return m_direction;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::jump()
{
    if (m_isGrounded) {
        setSpeed({ getSpeed().x, -this->jumpStrength });
        this->setDirection({ 0.0f, 1.0f });
    }
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::component::Movable::isGrounded() const
    -> bool
{
    return m_isGrounded;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Movable::setGrounded(
    bool value
)
{
    m_isGrounded = value;
}
