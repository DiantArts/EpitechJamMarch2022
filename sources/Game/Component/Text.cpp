///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>
#include <xrn/Ecs.hpp>
#include <Game/Window.hpp>
#include <Game/Scene.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Static
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::component::Text::loadFont(
    const ::std::string& filename
) -> ::sf::Font
{
    sf::Font font;
    if (!font.loadFromFile("./data/fonts/" + filename)) {
        throw ::std::runtime_error("Font failed to load: "s + filename);
    }
    return font;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// *structors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::component::Text::Text(
    const std::string& str,
    sf::Color color,
    ::xrn::Window& window
)
    : m_text{ str, this->font }
    , m_color{ color }
    , m_window{ &window }
{
    m_text.setFillColor(m_color);
    m_text.setCharacterSize(this->charSize);
    m_text.setOutlineColor(sf::Color::Black);
    m_text.setOutlineThickness(2);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Text::draw() const
{
    m_window->draw(m_text);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Text::set(
    const ::std::string& text
)
{
    m_text.setString(text);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Text::updatePosition(
    const ::xrn::component::Movable& movable
)
{
    m_text.setPosition(movable.getPosition());
}

auto ::xrn::component::Text::isOverlapping(
    const ::xrn::component::Hitbox& hitbox
) -> bool
{
    auto pos{ m_window->getMousePosition() };
    return hitbox.contains(pos);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::component::Text::setOverlapColor(
    const ::xrn::component::Hitbox& hitbox
)
{
    if (this->isOverlapping(hitbox)) {
        m_text.setFillColor(sf::Color::Black);
    } else {
        m_text.setFillColor(m_color);
    }
}
